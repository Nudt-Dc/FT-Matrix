.global DSPF_sp_qrd_inverse

.input Input_Nrows, Input_Ncols, Input_Q1:Input_Q0, Input_R1:Input_R0, Input_invA1:Input_invA0, Input_invR1:Input_invR0

.add_var Address_invR, Address_R, Address_Q, Address_invA                    
.add_var addr_code1, addr_code2, addr_code3, addr_code4                                  ;AM访存基址
.add_var offset_VSize8, offset_VSize16, offset_Ncols, offset24, offset16, offset32       ;AM访存偏移
.add_var Addr_Rcol, Addr_Rrow, offset_Rcol, offset_Rrow         ;广播基址变量，偏移变量
.add_var addr_MQ, addr_MR, addr_MA                              ;矩阵乘基址

.gen_var LOOP_I, LOOP_II, LOOP_III, judge                       ;循环变量，循环跳转变量
.gen_var factor1, factor2, h1, h2, Rcol, Rrow                   ;广播变量
.gen_var backup1:backup0, backup2, backup4:backup3, backup5     ;循环内备份恢复变量
.gen_var tmpRC1:tmpRC0, tmpRC2, tmpRR1:tmpRR0, tmpRR2           ;循环内计算访存分离变量
.gen_var tempQ, tempA, tempR, tempA_atom                        ;矩阵乘通用变量
.gen_var sum1, sum2, sum3                                       ;SVR 
.gen_var A1, B1, C1, D1, E1                                     ;SVR
.gen_var tmp_ARF1:tmpARF0, temp_address                         ;利用寄存器实现SADDA指令,为基址赋值
.gen_var Number0, Number47, Number64, float2                    ;通用数字变量                                     
.gen_var Vector_Size, N, temp_all                               ;向量SIZE，以及N，以及循环实现定点除法赋值

;为36位加法中间寄存器赋值
SMOVIL      0, tmp_ARF1
SMOVIH      0, tmp_ARF1

;以下为输入矩阵地址重新赋值到变量
SMVAGA36    Input_invR1:Input_invR0, Address_invR
SMVAGA36    Input_R1:Input_R0, Address_R
SMVAGA36    Input_Q1:Input_Q0, Address_Q
SMVAGA36    Input_invA1:Input_invA0, Address_invA

;让线性汇编器把Address_R和Address_invR识别为基址类型
SLDW        *+Address_R[0], tempA
SLDW        *+Address_invA[0], tempA
VLDW        *+Address_invR[0], tempR
VLDW        *+Address_Q[0], tempQ

;以下为通用数字变量赋值
SMOVIL      0, Number0
SMOVIH      0, Number0

SMOVIL      47, Number47
SMOVIH      0, Number47

SMOVIL      64, Number64
SMOVIH      0, Number64 

SMOVIL       0x40000000,float2
SMOVIH       0x40000000,float2

;以下为Vector_Size 和 N 赋值
SADD        15, Input_Ncols, Vector_Size
SADD        Number47, Input_Ncols, N

SMOVIL      0, temp_all
SMOVIH      0, temp_all 


    ;以下循环实现 i = Vector_Size / 16
    .GEMMV_LOOP: .loop
    SSUB    16, Vector_Size, Vector_Size
    SADD    1, temp_all, temp_all
    SLT     15, Vector_Size, judge             
    [judge]    SBR     .GEMMV_LOOP              
    .endloop

SMOV    temp_all, Vector_Size  ;Vector_Size = i;


SMOVIL      0, temp_all
SMOVIH      0, temp_all

    ;以下循环实现 j = N / 48
    .GEMMN_LOOP: .loop
    SSUB    Number47, N, N
    SSUB    1, N, N   ;N -= 48 (N -= (47+1))
    SADD    1, temp_all, temp_all
    SLT     Number47, N, judge             
    [judge]    SBR     .GEMMN_LOOP              
    .endloop

SMULISU 3, temp_all, N       ;N = j * 3



;以下为offset赋值
SMULISU     8, Vector_Size, tmpARF0                                                       
SMVAGA36    tmp_ARF1:tmpARF0, offset_VSize8                  ;为offset_VSize8赋值

SMULISU     16, Vector_Size, tmpARF0                                                     
SMVAGA36    tmp_ARF1:tmpARF0, offset_VSize16                 ;为offset_VSize16赋值

SMOVIL      16, tmpARF0
SMOVIH      0, tmpARF0
SMVAGA36    tmp_ARF1:tmpARF0, offset16                       ;为offset16赋值

SMOVIL      24, tmpARF0
SMOVIH      0, tmpARF0
SMVAGA36    tmp_ARF1:tmpARF0, offset24                       ;为offset24赋值

SMOVIL      32, tmpARF0
SMOVIH      0, tmpARF0
SMVAGA36    tmp_ARF1:tmpARF0, offset32                       ;为offset32赋值

SADD        1, Input_Ncols, tmpARF0 
SMVAGA36    tmp_ARF1:tmpARF0, offset_Rcol                    ;为标量访存偏移赋值

SMOV        Input_Ncols, tmpARF0                             
SMVAGA36    tmp_ARF1:tmpARF0, offset_Rrow                    ;为标量访存偏移赋值

SMOV        Input_Ncols, tmpARF0                             ;将offset中间变量赋值给赋值变量
SMVAGA36    tmp_ARF1:tmpARF0, offset_Ncols                   ;为offset_Ncols赋值


    ;备份第(col + 1)行
    SSUB        1, Input_Ncols, LOOP_I                      ;为循环体赋初值：col = Ncols - 1

    ;以下为基址addr_code1赋值
    SMULISU     Input_Ncols, Vector_Size, temp_address        
    SMULISU     temp_address, Number64, temp_address        ;为temp_address赋初值
    SMOV        temp_address, tmpARF0 
    SADDA       tmp_ARF1:tmpARF0, Address_invR, addr_code1 ;代码块1的基址0 = 矩阵地址 + 矩阵坐标

    ;为广播1基址变量赋值
    SMULISU     LOOP_I, Input_Ncols, temp_address           ;为基址中间变量赋值 LOOP_I * Ncols --> temp_address
    SADD        temp_address, LOOP_I, temp_address          ;为基址中间变量赋值 temp_address += LOOP_I
    SMULISU     4, temp_address, temp_address
    SMOV        temp_address, tmpARF0 
    SADDA       tmp_ARF1:tmpARF0, Address_R, Addr_Rcol      ;基址变量 = 矩阵地址 + 基址中间变量 Address_R + temp_address = Addr_Rcol
     
    .GEMM1_LOOP: .loop
    
    VLDDW       *addr_code1++[offset16], backup1:backup0
    VLDW        *+addr_code1[0], backup2

    SLDW        *Addr_Rcol--[offset_Rcol], Rcol

    SFRCPS32    Rcol, factor1              ;求倒数指令,并后续迭代两次增加精度

    ;迭代第一次，得到结果X[n+1]，并将 X[n+1] --> X[n]
    SFMULS32     Rcol, factor1, temp_all          
    SFSUBS32     temp_all, float2, temp_all	 
    SFMULS32     temp_all, factor1, factor1 

    ;迭代第二次，得到结果X[n+1]，并将 X[n+1] --> X[n]
    SFMULS32     Rcol, factor1, temp_all          
    SFSUBS32     temp_all, float2, temp_all	 
    SFMULS32     temp_all, factor1, factor1 

    SVBCAST     factor1, h1         ;广播

    SMOVIL  0, LOOP_II
    SMOVIH  0, LOOP_II      ;为循环体赋初值，k = 0

    ;以下为基址addr_code2赋值
    SMULISU     LOOP_I, Vector_Size, temp_address
    SMULISU     temp_address, Number64, temp_address            ;为temp_address赋初值
    SMOV        temp_address, tmpARF0 
    SADDA       tmp_ARF1:tmpARF0, Address_invR, addr_code2 ;代码块2的基址0 = 矩阵地址 + 矩阵坐标

    .GEMM2_LOOP: .loop       

    ;处理第col行 load
    VLDDW   *addr_code2++[offset16], tmpRC1:tmpRC0
    VLDW    *+addr_code2[0], tmpRC2


            SSUB        1, LOOP_I, LOOP_III          ;为循环体赋初值：row = col - 1
            SLT         LOOP_III, Number0, judge    ;判断是否满足循环条件：if(row < 0) judge = 1
            [judge]    SBR     .GEMM3_ENDLOOP       ;不满足条件则循环3跳转

            ;以下为基址addr_code3赋值
            SMULISU     LOOP_I, Vector_Size, temp_address
            SMULISU     temp_address, Number64, temp_address            ;为temp_address赋初值
            SMOV        temp_address, tmpARF0 
            SADDA       tmp_ARF1:tmpARF0, Address_invR, addr_code3 ;代码块3的基址0 = 矩阵地址 + 矩阵坐标

            ;以下为基址addr_code4赋值
            SMULISU     LOOP_III, Vector_Size, temp_address
            SADD        temp_address, LOOP_II, temp_address
            SMULISU     temp_address, Number64, temp_address            ;为temp_address赋初值
            SMOV        temp_address, tmpARF0 
            SADDA       tmp_ARF1:tmpARF0, Address_invR, addr_code4 ;代码块4的基址0 = 矩阵地址 + 矩阵坐标

            ;为广播2基址变量赋值
            SMULISU     LOOP_III, Input_Ncols, temp_address    ;为基址中间变量赋值 LOOP_III * Ncols --> temp_address
            SADD        temp_address, LOOP_I, temp_address    ;为基址中间变量赋值 temp_address += LOOP_I
            SMULISU     4, temp_address, temp_address
            SMOV        temp_address, tmpARF0 
            SADDA       tmp_ARF1:tmpARF0, Address_R, Addr_Rrow  ;基址变量 = 矩阵地址+ 基址中间变量 Address_R + temp_address = Addr_Rrow

            .GEMM3_LOOP: .loop      

            SLDW        *Addr_Rrow--[offset_Rrow], Rrow
            SFMULS32    Rrow, factor1, factor2      ;factor2 = Rrow * factor1
            SFSUBS32    factor2, Number0, factor2   ;factor2取反
            SVBCAST     factor2, h2                 ;广播

            ;备份第(row + 1)行
            VLDDW       *addr_code3++[offset16], backup4:backup3
            VLDW        *+addr_code3[0], backup5

;.label1:

            ;处理第(0-->col)行 load  
            VLDDW       *addr_code4++[offset16], tmpRR1:tmpRR0 
            VLDW        *+addr_code4[0], tmpRR2

            ;处理第(0-->col)行 process
            VFMULAS32   h2, tmpRC0, tmpRR0, tmpRR0 
            VFMULAS32   h2, tmpRC1, tmpRR1, tmpRR1 
            VFMULAS32   h2, tmpRC2, tmpRR2, tmpRR2 

            ;处理第(0-->col)行 store
            VSTW        tmpRR2, *addr_code4--[offset32]
            VSTDW       tmpRR1:tmpRR0, *addr_code4--[offset_VSize8] 

;.label2:

            ;恢复第(row + 1)行
            VSTW        backup5, *addr_code3--[offset32]
            VSTDW       backup4:backup3, *addr_code3--[offset_VSize8]
            

            SSUB        1, LOOP_III, LOOP_III       ;row--
            SLT         LOOP_III, Number0, judge    ;if(row < 0) judge = 1
            [!judge]   SBR     .GEMM3_LOOP          ;循环3跳转
            .GEMM3_ENDLOOP:
            .endloop                                ;循环3结束

        ;处理第col行 process
        VFMULS32 h1, tmpRC0, tmpRC0 
        VFMULS32 h1, tmpRC1, tmpRC1 
        VFMULS32 h1, tmpRC2, tmpRC2 

        ;处理第col行 store
        VSTW    tmpRC2, *addr_code2--[offset32] 
        VSTDW   tmpRC1:tmpRC0, *addr_code2++[offset24] 
        

        SADD    3, LOOP_II, LOOP_II         ;k += 3
        SLT     LOOP_II, N, judge           ;if(k < N) judge = 1
        [judge]    SBR     .GEMM2_LOOP      ;循环2跳转
        .endloop                            ;循环2结束                 

    ;恢复第(col + 1)行
    VSTW        backup2, *addr_code1--[offset32] 
    VSTDW       backup1:backup0, *addr_code1--[offset_VSize8] 

    SSUB        1, LOOP_I, LOOP_I       ;col--
    SLT         LOOP_I, Number0, judge  ; if(col < 0) judge = 1
    [!judge] SBR    .GEMM1_LOOP         ;循环1跳转
    .endloop                            ;循环1结束




SMOVIL      0, LOOP_I
SMOVIH      0, LOOP_I    ;为循环体A赋值

.GEMMa_LOOP: .loop      
 
    SMOVIL      0, LOOP_II
    SMOVIH      0, LOOP_II    ;为循环体B赋值

    SMULISU     Number64, LOOP_I, temp_address
    SMOV        temp_address, tmpARF0 
    SADDA       tmp_ARF1:tmpARF0, Address_Q, addr_MQ    ;为基址addr_MQ赋值

    .GEMMb_LOOP: .loop      

    VLDW        *addr_MQ++[offset_Ncols], tempQ   ;取tempQ

        SMOVIL      0, LOOP_III
        SMOVIH      0, LOOP_III    ;为循环体C赋值

        SMULISU     Number64, LOOP_I, temp_address
        SMOV        temp_address, tmpARF0 
        SADDA       tmp_ARF1:tmpARF0, Address_invR, addr_MR    ;为基址addr_MR赋值

        SMULISU     4, LOOP_II, temp_address
        SMOV        temp_address, tmpARF0 
        SADDA       tmp_ARF1:tmpARF0, Address_invA, addr_MA    ;为基址addr_MA赋值  

        .GEMMc_LOOP: .loop

        SADD        1, LOOP_III, LOOP_III               ;row += 1
        SLT         LOOP_III, Input_Nrows, judge        ;if(row < Nrows) judge = 1       

        VLDW        *addr_MR++[offset_VSize16], tempR       ;取tempR

        VFMULS32    tempR, tempQ, tempA_atom
        VMVCGC      tempA_atom, SVR
        
        ;.label3:

        SMOVIL      0, sum1
        SMOVIH      0, sum1
        SMOVIL      0, sum2
        SMOVIH      0, sum2
        SMOVIL      0, sum3
        SMOVIH      0, sum3

        ;.label4:

        ;单纯告诉线性汇编器，这里分配五个寄存器
        SMOVIL      0, A1
        SMOVIL      1, B1
        SMOVIL      2, C1
        SMOVIL      3, D1
        SMOVIL      4, E1

        ;.label5:

        SMVCCG      SVR0, A1

        SMVCCG      SVR1, B1

        SMVCCG      SVR2, C1
        SFADDS32    sum1, A1, sum1

        SMVCCG      SVR3, D1
        SFADDS32    sum2, B1, sum2

        SMVCCG      SVR4, E1
        SFADDS32    sum3, C1, sum3

        SMVCCG      SVR5, A1
        SFADDS32    sum1, D1, sum1

        SMVCCG      SVR6, B1
        SFADDS32    sum2, E1, sum2

        SMVCCG      SVR7, C1
        SFADDS32    sum3, A1, sum3

        SMVCCG      SVR8, D1
        SFADDS32    sum1, B1, sum1

        SMVCCG      SVR9, E1
        SFADDS32    sum2, C1, sum2

        SMVCCG      SVR10, A1
        SFADDS32    sum3, D1, sum3

        SMVCCG      SVR11, B1
        SFADDS32    sum1, E1, sum1

        SMVCCG      SVR12, C1
        SFADDS32    sum2, A1, sum2

        SMVCCG      SVR13, D1
        SFADDS32    sum3, B1, sum3

        SMVCCG      SVR14, E1
        SFADDS32    sum1, C1, sum1

        SMVCCG      SVR15, A1
        SFADDS32    sum2, D1, sum2

        SFADDS32    sum3, E1, sum3

        SFADDS32    sum1, A1, sum1

        SFADDS32    sum2, sum3, sum2
        SFADDS32    sum1, sum2, sum1
        
        ;.label6:

        ;invA[col + row * Ncols] += sum
        SLDW        *+addr_MA[0], tempA                 ;取tempA
        SFADDS32    tempA, sum1, tempA                  ;tempA += invA_atom
        SSTW        tempA, *addr_MA++[offset_Rrow]      ;写回tempA


        [judge]    SBR     .GEMMc_LOOP                  ;循环c跳转
        .endloop                                        ;循环c结束

    SADD        1, LOOP_II, LOOP_II                   ;col += 1
    SLT         LOOP_II, Input_Ncols, judge           ;if(col < Ncols) judge = 1
    [judge]    SBR     .GEMMb_LOOP                    ;循环b跳转
    .endloop                                          ;循环b结束

SADD        1, LOOP_I, LOOP_I                   ;k += 1
SLT         LOOP_I, Vector_Size, judge          ;if(k < Vector_Size) judge = 1
[judge]    SBR     .GEMMa_LOOP                  ;循环a跳转
.endloop                                        ;循环a结束


.size DSPF_sp_qrd_inverse, .-DSPF_sp_qrd_inverse